{'CLASSES': {'forest.Forest': {'bases': [],
                               'constructor': ['roots'],
                               'docstring': '\n    Forest representing the union of all strategies for a formula\n    ',
                               'methods': [('export',
                                            ['fname', "format='GraphML'"],
                                            "\n        Export the subtree rooted at self in 'dot' or 'GraphML' format\n        into a file with 'fname'.\n        "),
                                           ('traverse',
                                            ['bfs=False'],
                                            "\n        Generator for traversing self.\n        Depth first by default, breadth first if 'bfs'\n        "),
                                           ('_removeNode',
                                            ['node'],
                                            "\n        Remove the node 'node' from self.\n        "),
                                           ('_filterOut',
                                            ['predicate'],
                                            "\n        Remove each node that satisfies predicate. 'predicate' must be\n        a function accepting Node and returning Boolean.\n        "),
                                           ('true',
                                            [],
                                            '\n        Factory for the forest of nodes representing all system states.\n        No rules are assigned.\n        '),
                                           ('localDisjunction',
                                            ['locStates'],
                                            "\n        Factory for the forest of nodes representing all system states \n        composed of 'locStates'.\n        No rules are assigned.\n        locStates is a list of |model.agt| iterables over local states.\n        locStates[i] is an iterable over all local states that agent i \n        may be at.\n        "),
                                           ('_globalSuffixes',
                                            ['locStates', 'length'],
                                            "\n        Generate list of the suffixes  of given 'length' of all global states\n        composed of local states specified in locStates.\n        "),
                                           ('combinationPredicate',
                                            ['agtNum', 'agtStates'],
                                            '\n        Factory of the forest for all system states, where |agtNum| agents\n        have local states from the set of agtStates.\n        '),
                                           ('conjunction',
                                            ['f2'],
                                            "\n        Remove from both forests (self and f2) every node that has no weak\n        equivalent in the other forest. By weak equivalent of a node N is\n        meant a node representing the same state and a strategy that is\n        a subset of N's strategy. Join the remnants of the two forests and\n        assign them to self.\n        "),
                                           ('_hasWeakEquivalent',
                                            ['node'],
                                            "\n        Helper for Conjunction. \n        Return False if there is no weak equivalent of node in self, return\n        True otherwise. Mark every strong equivalent of node in self with\n        'included' flag. By strong equivalent of a node N is meant a node\n        representing the same state and a strategy that is a strict superset\n        of N's strategy.\n        "),
                                           ('disjunction',
                                            ['f2'],
                                            '\n        Merge the two forests (self and f2) into self.\n        '),
                                           ('next',
                                            [],
                                            '\n        Transform the forest (for psi) into the forest for X(psi).\n        '),
                                           ('_recNext',
                                            ['node', 'strategyRules'],
                                            ' \n        Recursive subroutine for Next.\n        Recursively append all possible predecessors compatible with\n        strategyRules to the subtree of itself rooted at node.\n        '),
                                           ('always',
                                            [],
                                            '\n        Return forest for G(psi).\n        '),
                                           ('_cycle',
                                            ['node', 'strategyRules'],
                                            "\n        Recursive subroutine for Always\n        Extend 'node' having 'strategyRules' with the (pruned)\n        trees from self, until a cycle is formed (roots correspond) or\n        there is nothing to attach.\n        Return the roots of trees with cycle closed at or under the node,\n        which are extended to maximum. \n        "),
                                           ('until',
                                            ['f1'],
                                            '\n        Given the forest f1 for psi1, it transforms the forest (for psi2) into\n        the forest for (psi1)U(psi2)\n        '),
                                           ('_appendPsi1',
                                            ['node', 'strategyRules', 'root', 'f1'],
                                            "\n        Recursive subroutine for Until.\n        Extend the subtree of itself rooted at 'node', which is a subtree of\n        a tree rooted at 'root', with the subforest of f1 that is compatible\n        with strategyRules.\n        "),
                                           ('_merge',
                                            ['node', 'parent'],
                                            "\n        Recursive subroutine for Until.\n        Merge the tree rooted at the node into the subtree of self rooted at\n        the parent.\n        Simply append to the parrent if node is not equal to any of parent's\n        predecessors, recursively merge otherwise.\n        "),
                                           ('totalStrategy',
                                            [],
                                            "\n        Return a single strategy defined for all states included in\n        the forest, if there is one. Return 'None' otherwise.\n        ")],
                               'properties': ['roots', 'depth']},
             'forest.Node': {'bases': [],
                             'constructor': ['node=None'],
                             'docstring': '\n    One node of the forest\n    ',
                             'methods': [('__repr__', [], ''),
                                         ('factory',
                                          ['state', 'rules', 'succ=None'],
                                          "\n        Return new Node representing tuple 'state' and rules from\n        iterable 'rules', having successor Node 'succ'.\n        "),
                                         ('equals',
                                          ['node'],
                                          ' \n        Return True if self and node represent the same state and rules.\n        '),
                                         ('conflict',
                                          ['rules2'],
                                          '\n        Return True if a rule from rules1 is conflicting with a rule from\n        rules2.\n        Return False otherwise.\n        '),
                                         ('__deepcopy__',
                                          ['memo'],
                                          '\n        Return the copy of the entire subtree rooted at self.\n        '),
                                         ('root',
                                          [],
                                          "\n        Return node's root.\n        "),
                                         ('changeSubtreeSize',
                                          ['delta'],
                                          '\n        Change the subtreeSize of self with delta and propagate change to\n        all successors up to the root.\n        '),
                                         ('allRules',
                                          [],
                                          '\n        Return the union of all rules on the way from self to the root.\n        '),
                                         ('sortPredecessors',
                                          [],
                                          '\n        Sort the set of predecessors into a list according to the sizes of\n        their subtrees.\n        Recursively for the entire subtree rooted at self.\n        Changes preds from set to list!\n        '),
                                         ('cpPrune',
                                          ['rules'],
                                          '\n        Return a copy of the subtree rooted at self and pruned with rules.\n        '),
                                         ('cpPropagate',
                                          ['rules'],
                                          "\n        Return a copy of the subtree rooted at self where the nodes'\n        rules are extended with the 'rules' when compatible and the nodes\n        are removed when incompatible.\n        "),
                                         ('_cpUpdate',
                                          ['rules', 'propagate=False'],
                                          "\n        Return a copy of the subtree rooted at self and pruned with\n        'rules'. If 'propagate' is True then the nodes in the copy are\n        extended with 'rules'.\n        "),
                                         ('preimage',
                                          ['strategyRules'],
                                          '\n        Return the set of all possible predecessors of itself that are\n        compatible with given strategy\n        '),
                                         ('_findPreds',
                                          ['rules', 'vector'],
                                          "\n        Return the set of all preceding Nodes with system states starting with\n        'vector' from which self is reached by executing rules from\n        'rules' by the respective agents:\n        vector - list of pairs (individual state, rule) for the first x agents\n        rules - dictionary of pairs (individual state 'q', set of rules 'r')\n        where q is a state from self and 'r' are some rules with outcome q\n        "),
                                         ('singleExport',
                                          ['fname', "format='GraphML'"],
                                          "\n        Export the subtree rooted at self in format 'format' into a file with\n        fname.\n        "),
                                         ('export',
                                          ['f', 'format'],
                                          "\n        Export the subtree rooted at self as a part of a graph in 'format'\n        into open file 'f'.\n        "),
                                         ('_traverseNode',
                                          ['f', 'format'],
                                          "\n        Write istelf in 'format' into file 'f'.\n        "),
                                         ('_traverseEdge',
                                          ['f', 'format'],
                                          "\n        Write all edges to its predecessors in format 'format' into file 'f'.\n        ")],
                             'properties': ['state',
                                            'rules',
                                            'succ',
                                            'preds',
                                            'subtreeSize',
                                            'included']},
             'main.Usage': {'bases': ['Exception'],
                            'constructor': ['msg'],
                            'docstring': '',
                            'methods': [],
                            'properties': ['msg']},
             'strategy.Strategy': {'bases': [],
                                   'constructor': [],
                                   'docstring': 'partial strategy: rules + domain',
                                   'methods': [('export',
                                                ['fname'],
                                                "Export the domain (list of states) and the rules into 'fname' file.\n        ")],
                                   'properties': ['rules', 'domain']},
             'tests.testForest.FactoriesTestCase': {'bases': ['unittest.TestCase'],
                                                    'constructor': [],
                                                    'docstring': '\n    Testing forest factories for atomic predicates specifying global states.\n    Content of nodes is model-specific.\n    ',
                                                    'methods': [('testLocalDisjunction',
                                                                 [],
                                                                 ''),
                                                                ('testCombinationPredicate',
                                                                 [],
                                                                 '')],
                                                    'properties': []},
             'tests.testForest.ForestOpsTestCase': {'bases': ['unittest.TestCase'],
                                                    'constructor': [],
                                                    'docstring': '\n    Testing basic operations on forest, not strategy- or model-specific.\n    Content of the nodes is irrelevant.\n    ',
                                                    'methods': [('setUp', [], ''),
                                                                ('createTree', ['size'], ''),
                                                                ('testTraverse',
                                                                 [],
                                                                 'traverse must visit all nodes in a forest'),
                                                                ('test_removeNode',
                                                                 [],
                                                                 "_removeNode must keep node's subtrees as new trees in the forest")],
                                                    'properties': ['size', 'f']},
             'tests.testForest.PredicateOpsTestCase': {'bases': ['unittest.TestCase'],
                                                       'constructor': [],
                                                       'docstring': '\n    Testing predicate logic operations on the forests. \n    Content of the nodes is relevant.\n    ',
                                                       'methods': [('setUp', [], ''),
                                                                   ('equivalentIn',
                                                                    ['node',
                                                                     'forest',
                                                                     'predicate'],
                                                                    'Check if forest has a node with the same state and an equivalent\n        set of rules. \n        Predicate is a subset (weak), equivalence or a superset (strong).\n        '),
                                                                   ('testConjunctionSoundness',
                                                                    [],
                                                                    'Every node in the result must have an equivalent in one operand\n        and a weak equivalent in the other operand.\n        '),
                                                                   ('testConjunctionCompleteness',
                                                                    [],
                                                                    'For each operand and each its node that is not represented in\n        the result there must be no weak equivalent in the other operand.\n        '),
                                                                   ('testDisjunctionSoundness',
                                                                    [],
                                                                    'For each node from the result there must be the same\n        node in one of the operands.\n        '),
                                                                   ('testDisjunctionCompleteness',
                                                                    [],
                                                                    'For each node from each operand there must be the same node in\n        the result.\n        ')],
                                                       'properties': ['fPairs']},
             'tests.testTrie.TrieTestCase': {'bases': ['unittest.TestCase'],
                                             'constructor': [],
                                             'docstring': '\n    Testing consistency of Trie\n    ',
                                             'methods': [('setUp',
                                                          [],
                                                          '\n        Load the serialized test tree and construct the trie. \n        '),
                                                         ('testDeltas',
                                                          [],
                                                          'Descendants must add deltas to ancestors.\n        ')],
                                             'properties': ['t']},
             'trie.Trie': {'bases': [],
                           'constructor': ['forest'],
                           'docstring': '\n    Prefix tree (trie) for finding a complete strategy. Constructed from\n    the forest for a formula. An edge represents a rule (perception, action),\n    all edges on the same level represent the same rule. The edges leading \n    to one node are sorted by the action assigned to the perception.\n    Nodes contain all system states for which the strategy composed of\n    the rules on the way to the root works.\n    As soon as a node containing all states to be covered is added, we are\n    finished - the strategy composed of the rules on the branch is the total\n    strategy.\n    Following the ordering of the preds in the forest and putting the most \n    used rules high in the trie, we should be keeping the size of the trie \n    close to minimal.  \n    ',
                           'methods': [('strategy',
                                        [],
                                        '\n        Build trie until a leaf containing all system states is created.\n        Return the rules on the branch from the node to the root.\n        '),
                                       ('addNode',
                                        ['node'],
                                        '\n        Extend trie with new rules from the node.\n        '),
                                       ('_propagateNode',
                                        ['trieNode', 'nodeStr', 'nodeState'],
                                        '\n        Add nodeState to trieNode if nodeStr is epmty.\n        Otherwise, propagate nodeState deeper in the trie while following \n        the rules from nodeStr.\n        Return trieNode if it covers all states to cover, None otherwise. \n        '),
                                       ('export',
                                        ['tname', "format='GraphML'"],
                                        "\n        Export the trie in 'dot' or 'GraphML' format into 'tname' file.\n        "),
                                       ('traverse',
                                        ['root=None'],
                                        "\n        Generator for traversing (sub)trie rooted at 'root' \n        (depth first).\n        ")],
                           'properties': ['levels',
                                          'levelSet',
                                          'depth',
                                          'root',
                                          'forest',
                                          'statesToCover']},
             'trie.TrieNode': {'bases': [],
                               'constructor': [],
                               'docstring': '',
                               'methods': [('export',
                                            ['f', 'levels', 'format'],
                                            '\n        Export the subtrie rooted at self as a part of a dot graph into\n        open file f.\n        '),
                                           ('_traverseNode',
                                            ['f', 'format'],
                                            '\n        Write istelf as a dot command into file f.\n        '),
                                           ('_traverseEdge',
                                            ['f', 'levels', 'format'],
                                            '\n        Write all edges to its predecessors as dot commands into file f.\n        ')],
                               'properties': ['states',
                                              'delta',
                                              'level',
                                              'action',
                                              'parent',
                                              'children']}},
 'CONSTANTS': ['main.help_message',
               'model.agt',
               'model.act',
               'model.st',
               'model.k',
               'model.mask',
               'utils.usedRules',
               'utils.usedPerceptions',
               'utils.usedStates',
               'utils.strategyPath',
               'utils.graphHeader',
               'utils.graphFooter',
               'model consesus.agt',
               'model consesus.act',
               'model consesus.st',
               'model consesus.k',
               'model consesus.mask',
               'model leader.agt',
               'model leader.act',
               'model leader.st',
               'model leader.k',
               'model leader.mask'],
 'FUNCTIONS': [('formula.phi', [], ' Create the forest for model formula.\n    '),
               ('main.main', ['argv=None'], ''),
               ('model.neig',
                ['a', 'n'],
                '\n    topology encoding => model-specific\n    returns n-th neighbor of agent a\n    '),
               ('model.neig_1',
                ['a', 'na'],
                "\n    model-specific (faster)\n    returns the index of a's neighbor na\n    "),
               ('model.manif',
                ['q'],
                '\n    general\n    returns the manifestation of individual state q \n    '),
               ('model.iState',
                ['prc'],
                '"\n    general\n    returns the individual state from a perception\n    '),
               ('model.tran',
                ['prc', 'action'],
                '\n    transition function => model specific\n    returns outcome of action act at perception prc\n    '),
               ('model.tran_1',
                ['l_state'],
                '\n    inverted tr.fun. => model specific\n    returns list of rules with outcome l_state  \n    '),
               ('utils.wTran_1', ['l_state'], ''),
               ('utils.getRefRule', ['rule'], ''),
               ('utils.getRefState', ['state'], ''),
               ('utils.outputPath',
                [],
                ' Make sure the output directory exists and return its path.\n    '),
               ('model consesus.neig',
                ['a', 'n'],
                '\n    topology encoding => model-specific\n    returns n-th neighbor of agent a\n    '),
               ('model consesus.neig_1',
                ['a', 'na'],
                "\n    model-specific (faster)\n    returns the index of a's neighbor na\n    "),
               ('model consesus.manif',
                ['q'],
                '\n    general\n    returns the manifestation of individual state q \n    '),
               ('model consesus.iState',
                ['prc'],
                '"\n    general\n    returns the individual state from a perception\n    '),
               ('model consesus.tran',
                ['prc', 'action'],
                '\n    transition function => model specific\n    returns outcome of action act at perception prc\n    '),
               ('model consesus.tran_1',
                ['l_state'],
                '\n    inverted tr.fun. => model specific\n    returns list of rules with outcome l_state  \n    '),
               ('model leader.neig',
                ['a', 'n'],
                '\n    topology encoding => model-specific\n    returns n-th neighbor of agent a\n    '),
               ('model leader.neig_1',
                ['a', 'na'],
                "\n    model-specific (faster)\n    returns the index of a's neighbor na\n    "),
               ('model leader.manif',
                ['q'],
                '\n    general\n    returns the manifestation of individual state q \n    '),
               ('model leader.iState',
                ['prc'],
                '"\n    general\n    returns the individual state from a perception\n    '),
               ('model leader.tran',
                ['prc', 'action'],
                '\n    transition function => model specific\n    returns outcome of action act at perception prc\n    '),
               ('model leader.tran_1',
                ['l_state'],
                '\n    inverted tr.fun. => model specific\n    returns list of rules with outcome l_state  \n    ')],
 'HIERARCHY': ['forest',
               'formula',
               'main',
               'model',
               'strategy',
               'trie',
               'utils',
               'model consesus',
               'model leader',
               'tests',
               'tests.testForest',
               'tests.testTrie'],
 'POINTERS': {'forest.combinations': 'itertools.combinations',
              'forest.copy': 'copy',
              'forest.deque': 'collections.deque',
              'forest.model': 'model',
              'forest.product': 'itertools.product',
              'forest.trie': 'trie',
              'forest.utils': 'utils',
              'formula.forest': 'forest',
              'main.formula': 'formula',
              'main.getopt': 'getopt',
              'main.pickle': 'pickle',
              'main.sys': 'sys',
              'main.time': 'time',
              'main.utils': 'utils',
              'tests.testForest.collections': 'collections',
              'tests.testForest.copy': 'copy',
              'tests.testForest.forest': 'forest',
              'tests.testForest.itertools': 'itertools',
              'tests.testForest.model': 'model',
              'tests.testForest.unittest': 'unittest',
              'tests.testTrie.pickle': 'pickle',
              'tests.testTrie.trie': 'trie',
              'tests.testTrie.unittest': 'unittest',
              'tests.testTrie.utils': 'utils',
              'trie.deque': 'collections.deque',
              'trie.forest': 'forest',
              'trie.model': 'model',
              'trie.product': 'itertools.product',
              'trie.strategy': 'strategy',
              'trie.utils': 'utils',
              'utils.isdir': 'os.path.isdir',
              'utils.mkdir': 'os.mkdir',
              'utils.model': 'model'}}
